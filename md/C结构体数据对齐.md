# C结构体数据对齐

## 为什么要内存对齐（why）

使用字节对齐可以提升CPU读取数据的效率。

CPU的位数由地址总线宽度决定，表示一次等处理的二进制位数。操作系统的位数是由字长决定（word size）。字长决定了指针的大小，指针的大小决定了操作系统中的虚拟空间的最大值。

CPU每次都是从以4字节（32位CPU）或是8字节（64位CPU）的整数倍的内存地址中读进数据的（例如32位的只能0x00000004、0x00000008这种地址一次读4字节的数据）。如果数据不对齐，例如一个int类型放在0x00000004、0x00000008这两个内存地址中间，CPU就会多次读取，如果把整形对齐存放在0x00000008就可以一次读取出来。

## 测试（64位）

[查看操作系统位数](https://github.com/matiastang/Computer-story/blob/master/md/%E6%9F%A5%E7%9C%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%9A%E5%B0%91%E4%BD%8D.md)

**重要**结构体sizeof大小总为一个结构体中数据占用空间最大的那个变量的倍数.
**重要**当有结构体包含结构体时，找出所有包含结构体中变量最大的那个一个，数据补齐就按照他的空间大小补齐，然后依次计算出包含的结构体大小，再对其他变量进行计算。

计算结构体的大小，先要找到里面空间最大的变量，再从头到尾第一个变量到最后一个变量空间依次相加并对不足进行补齐。
由此可见，如果结构体里面的数据变量按照空间从大到小或者从小到大依次排列，可以节省空间。

当然，默认是进行对齐处理的，如果接触过通信协议的代码，构造报文的结构后面基本上都有这么一句话，__attribute__ ((packed))，这个是将这个结构按照实际字符来存储，不做对齐处理，这样有什么好处呢，通过指定的偏移量就可以快速获取指定的参数值。

```c
struct structOne {
    char a;
};
// sizeof=1
```
只有一个char类型，占用一个字节。

```c
struct structOne {
    char a;
    int b;
};
// sizeof=8
```
一个char类型，占用一个字节。一个int占用4个字节（64位系统）。(1 + 3) + 4 = 8。对char补齐了3个字节。

```c
struct structOne {
    char a;
    int b;
    char c;
};
// sizeof=12
```
一个char类型，占用一个字节。一个int占用4个字节（64位系统）。(1 + 3) + 4 + (1 + 3) = 12.

```c
struct structOne {
    char a;
    char c;
    int b;
};
// sizeof=8
```
一个char类型，占用一个字节。一个int占用4个字节（64位系统）。(1 + 1 + 2) + 4 = 8.

结构体包含结构体时：
```c
struct structTwo {
    long long a;
    char b;
};

struct structThree {
    char a[5];
    int b;
    struct structTwo c;
};

// two sizeof=16
// three sizeof=32
```
`structTwo`结构体占用: 8 + (1 + 7) = 16.
`structThree`结构体占用：(5 + 3) + (4 + 4) + 16 = 32